#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 23 15:44:33 2019

@author: mkowalska
"""
import numpy as np
from numpy import exp, isfinite
from scipy.integrate import simps 
from functools import wraps
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib import cm
from matplotlib import gridspec
from matplotlib.mlab import griddata
from mpl_toolkits.mplot3d import Axes3D
from kcsd import KCSD3D


def get_states_3D(seed):
    """
    Used in the random seed generation for 3D sources
    """
    rstate = np.random.RandomState(seed)  # seed here!
    states = rstate.random_sample(24)
    return states


def gauss_3d_small(csd_at, seed=0):
    '''A random quadpole small souce in 3D'''
    x, y, z = csd_at
    states = get_states_3D(seed)
    x0, y0, z0 = [0.1, 0., 7.35]
    x1, y1, z1 = [0.1, 0., 7.25]
    sig_2 = 0.01
    p1, p2, p3 = (ii*0.5 for ii in states[8:11])
    A = (2*np.pi*sig_2)**-1
    f1 = A*np.exp((-(x-x0)**2 - (y-y0)**2 - (z-z0)**2) / (2*sig_2))
    f2 = -1*A*np.exp((-(x-x1)**2 - (y-y1)**2 - (z-z1)**2) / (2*sig_2))
    x2, y2, z2 = [0.9, 0., 7.35]
    x3, y3, z3 = [0.9, 0., 7.25]
    f3 = -A*np.exp((-(x-x2)**2 - (y-y2)**2 - (z-z2)**2) / (2*sig_2))
    f4 = 1*A*np.exp((-(x-x3)**2 - (y-y3)**2 - (z-z3)**2) / (2*sig_2))
    f = f1+f2+f3+f4
    f /= np.max(np.abs(f))
    return f


def integrate_3D(x, y, z, xlim, ylim, zlim, csd, xlin, ylin, zlin, X, Y, Z):
    """
    X,Y - parts of meshgrid - Mihav's implementation
    """
    Nz = zlin.shape[0]
    Ny = ylin.shape[0]
    m = np.sqrt((x - X)**2 + (y - Y)**2 + (z - Z)**2)
    m[m < 0.0000001] = 0.0000001
    z = csd / m
    Iy = np.zeros(Ny)
    for j in range(Ny):
        Iz = np.zeros(Nz)                        
        for i in range(Nz):
            Iz[i] = simps(z[:,j,i], zlin)
        Iy[j] = simps(Iz, ylin)
    F = simps(Iy, xlin)
    return F 


def calculate_potential_3D(true_csd, ele_xx, ele_yy, ele_zz, 
                           csd_x, csd_y, csd_z):
    """
    For Mihav's implementation to compute the LFP generated
    """
    xlin = csd_x[:,0,0]
    ylin = csd_y[0,:,0]
    zlin = csd_z[0,0,:]
    xlims = [xlin[0], xlin[-1]]
    ylims = [ylin[0], ylin[-1]]
    zlims = [zlin[0], zlin[-1]]
    sigma = 1./300.
    pots = np.zeros(len(ele_xx))
    for ii in range(len(ele_xx)):
        pots[ii] = integrate_3D(ele_xx[ii], ele_yy[ii], ele_zz[ii],
                                xlims, ylims, zlims, true_csd, 
                                xlin, ylin, zlin, 
                                csd_x, csd_y, csd_z)
        print('Electrode:', ii)
    pots /= 4*np.pi*sigma
    return pots


def do_kcsd(ele_pos, pots, **params):
    """
    Function that calls the KCSD3D module
    """
    num_ele = len(ele_pos)
    pots = pots.reshape(num_ele, 1)
    k = KCSD3D(ele_pos, pots, **params)
    pre_cv = k.values('CSD')
    #k.cross_validate(Rs=np.arange(0.2,0.4,0.02))
    k.cross_validate(Rs=np.arange(0.02,0.4,0.02), lambdas=np.array([0]))
#    k.cross_validate(Rs=np.array(0.31).reshape(1))
    est_csd = k.values('CSD')
    return k, pre_cv, est_csd


def grid(x, y, z, resX=100, resY=100):
    """
    Convert 3 column data to matplotlib grid
    """
    x = x.flatten()
    y = y.flatten()
    z = z.flatten()
    xi = np.linspace(min(x), max(x), resX)
    yi = np.linspace(min(y), max(y), resY)
    zi = griddata(x, y, z, xi, yi, interp='linear')
    return xi, yi, zi


def make_plots(fig_title, 
               csd_at, true_csd, 
               ele_x, ele_y, ele_z, pots,
               k, pre_cv, est_csd):
    """
    Shows 3 plots
    1_ true CSD generated based on the random seed given
    2_ interpolated LFT (NOT kCSD pot though), generated by simpsons rule integration
    3_ results from the kCSD 2D for the default values
    """
    k_csd_x, k_csd_y, k_csd_z = k.estm_x, k.estm_y, k.estm_z
    t_csd_x, t_csd_y, t_csd_z = csd_at
    fig = plt.figure(figsize=(13, 16))
    #True CSD
    z_steps = 5
    height_ratios = [1 for i in range(z_steps)]
    height_ratios.append(0.1)
    gs = gridspec.GridSpec(z_steps+1, 4, height_ratios=height_ratios)
    t_max = np.max(np.abs(true_csd))
    levels = np.linspace(-1*t_max, t_max, 16)
    ind_interest = np.mgrid[0:k_csd_z.shape[2]:np.complex(0,z_steps+2)]
    ind_interest = np.array(ind_interest, dtype=np.int)[1:-1]
    for ii, idx in enumerate(ind_interest):
        ax = plt.subplot(gs[ii, 0])
        im = plt.contourf(t_csd_x[:,:,idx], t_csd_y[:,:,idx], true_csd[:,:,idx], 
                          levels=levels, cmap=cm.bwr_r)
        # ax.get_xaxis().set_visible(False)
        # ax.get_yaxis().set_visible(False)
        title = str(t_csd_z[:,:,idx][0][0])[:4]
        ax.text(0.7, 0.9, 'z='+title, fontsize=10, transform=ax.transAxes)
        ax.set_aspect('equal')
        ax.set_xlabel('X (mm)')
        ax.set_ylabel('Y (mm)')
        if ii == 0:
            ax.set_title('True CSD')
        ax.set_xticks([0, 0.5, 1.])
        ax.set_yticks([0, 0.5, 1])
    cax = plt.subplot(gs[z_steps,0])
    cbar = plt.colorbar(im, cax=cax, orientation='horizontal')
    cbar.set_ticks([-1, 0, 1])
    cbar.set_ticklabels([-1, 0, 1])
    cbar.set_label(r'CSD ($\mathrm{\mu}A/{mm}^3$)')
    #cbar.set_ticks(levels[::2])
    #cbar.set_ticklabels(np.around(levels[::2], decimals=2))
    #Potentials
    v_max = np.max(np.abs(pots))
    levels_pot = np.linspace(-1*v_max, v_max, 16)
#    ele_res = int(np.ceil(len(pots)**(3**-1)))    
#    ele_x = ele_x.reshape(ele_res, ele_res, ele_res)
#    ele_y = ele_y.reshape(ele_res, ele_res, ele_res)
#    ele_z = ele_z.reshape(ele_res, ele_res, ele_res)
    pots = pots.reshape(ele_x.shape[0], ele_x.shape[1], ele_x.shape[2])
#    print('ele_pos', ele_x.shape, 'pots', pots.shape)
    for ii, idx in enumerate(range(min(5,ele_x.shape[0]))):
        X,Y,Z = grid(ele_x[:,:,idx], ele_y[:,:,idx], pots[:,:,idx])
        ax = plt.subplot(gs[idx, 1])
        im = plt.contourf(X, Y, Z, levels=levels_pot, cmap=cm.PRGn)
#        print(ele_x[:,:,idx].shape)
        plt.scatter(ele_x[:,:,idx], ele_y[:,:,idx], 5, color='k')
        # ax.get_xaxis().set_visible(False)
        # ax.get_yaxis().set_visible(False)
        title = str(ele_z[:,:,idx][0][0])[:4]
        ax.text(0.7, 0.9, 'z='+title, fontsize=10, transform=ax.transAxes)
        #ax.set_title(label='z='+title, fontdict={'x':0.8, 'y':0.8}, fontsize=10)
        ax.set_aspect('equal')
        ax.set_xlim([-0.1, 1.1])
        ax.set_ylim([-0.3,0.9])
        ax.set_xlabel('X (mm)')
        ax.set_ylabel('Y (mm)')
        ax.set_xticks([0, 0.5, 1])
        ax.set_yticks([0, 0.5, 1])
        if ii == 0:
            ax.set_title('Interpolated potentials')
        
    cax = plt.subplot(gs[z_steps,1])
    cbar2 = plt.colorbar(im, cax=cax, orientation='horizontal')
    cbar2.set_ticks([-1*v_max, 0, v_max])
    cbar2.set_ticklabels(np.around([-1*v_max, 0, v_max], decimals=3))
    cbar2.set_label(r'Potential ($mV$)')
    # #KCSD - pre_cv
    t_max = np.max(np.abs(pre_cv[:,:,:,0]))
    levels_kcsd = np.linspace(-1*t_max, t_max, 16)
    ind_interest = np.mgrid[0:k_csd_z.shape[2]:np.complex(0,z_steps+2)]
    ind_interest = np.array(ind_interest, dtype=np.int)[1:-1]
    for ii, idx in enumerate(ind_interest):
        ax = plt.subplot(gs[ii, 2])
        im = plt.contourf(k_csd_x[:,:,idx], k_csd_y[:,:,idx], pre_cv[:,:,idx,0], 
                          levels=levels_kcsd, cmap=cm.bwr_r)
        #im = plt.contourf(k_csd_x[:,:,idx], k_csd_y[:,:,idx], est_csd[:,:,idx,0], 
        #                  levels=levels, cmap=cm.bwr_r)
        # ax.get_xaxis().set_visible(False)
        # ax.get_yaxis().set_visible(False)
        title = str(k_csd_z[:,:,idx][0][0])[:4]
        #ax.set_title(label='z='+title, fontdict={'x':0.8, 'y':0.8}, fontsize=10)
        ax.text(0.7, 0.9, 'z='+title, fontsize=10, transform=ax.transAxes)
        ax.set_aspect('equal')
        ax.set_xlabel('X (mm)')
        ax.set_ylabel('Y (mm)')
        ax.set_xticks([0, 0.5, 1])
        ax.set_yticks([0, 0.5, 1])
        if ii == 0:
            ax.set_title('kCSD3D')
    cax = plt.subplot(gs[z_steps,2])
    cbar3 = plt.colorbar(im, cax=cax, orientation='horizontal')
    cbar3.set_ticks([-1*t_max, 0 , t_max])
    cbar3.set_ticklabels(np.around([-1*t_max, 0 , t_max], decimals=2))
    cbar3.set_label(r'kCSD ($\mathrm{\mu}A/{mm}^3$)')
    # kCSD post CV
    t_max = np.max(np.abs(est_csd[:,:,:,0]))
    levels_kcsd = np.linspace(-1*t_max, t_max, 16)
    ind_interest = np.mgrid[0:k_csd_z.shape[2]:np.complex(0,z_steps+2)]
    ind_interest = np.array(ind_interest, dtype=np.int)[1:-1]
    for ii, idx in enumerate(ind_interest):
        ax = plt.subplot(gs[ii, 3])
        im = plt.contourf(k_csd_x[:,:,idx], k_csd_y[:,:,idx], est_csd[:,:,idx,0], 
                          levels=levels_kcsd, cmap=cm.bwr_r)
        #im = plt.contourf(k_csd_x[:,:,idx], k_csd_y[:,:,idx], est_csd[:,:,idx,0], 
        #                  levels=levels, cmap=cm.bwr_r)
        # ax.get_xaxis().set_visible(False)
        # ax.get_yaxis().set_visible(False)
        title = str(k_csd_z[:,:,idx][0][0])[:4]
        #ax.set_title(label='z='+title, fontdict={'x':0.8, 'y':0.8}, fontsize=10)
        ax.text(0.7, 0.9, 'z='+title, fontsize=10, transform=ax.transAxes)
        ax.set_aspect('equal')
        ax.set_xlabel('X (mm)')
        ax.set_ylabel('Y (mm)')
        ax.set_xticks([0, 0.5, 1])
        ax.set_yticks([0, 0.5, 1])
        if ii == 0:
            ax.set_title('kESI')
    cax = plt.subplot(gs[z_steps, 3])
    cbar4 = plt.colorbar(im, cax=cax, orientation='horizontal')
    cbar4.set_ticks([-1*t_max, 0 , t_max])
    cbar4.set_ticklabels(np.around([-1*t_max, 0 , t_max], decimals=2))
    cbar4.set_label(r'kCSD ($\mathrm{\mu}A/{mm}^3$)')
    # fig.suptitle("Lambda,R,CV_Error,RMS_Error,Time = "+fig_title)
    fig.suptitle(fig_title)

    gs.tight_layout(fig, rect=[0, 0.03, 1, 0.95])  
    # #Showing
    # plt.tight_layout()

    plt.show()
    return fig


csd_profile = gauss_3d_small
csd_at = np.mgrid[0.:9:50j,
                  0.:9:50j,
                  0.:9:50j]
f = csd_profile(csd_at, seed=1)
x, y, z = csd_at
ele_x, ele_y, ele_z = np.mgrid[0.:1.:5j,
                               -0.2:0.8:5j,
                               6.7:7.7:5j]
ele_pos = np.array([ele_x.flatten(), ele_y.flatten(), ele_z.flatten()])

#pots = calculate_potential_3D(f, ele_pos[0], ele_pos[1], ele_pos[2], x, y, z)
vals_pots = np.load('/home/mkowalska/FEM/kESI/pots_6_higher.npy')

gdX = 0.04
gdY = 0.04
gdZ = 0.04
x_lims = [-0.1,1.1] #CSD estimation place
y_lims = [-0.3,0.9]
z_lims = [6.6,7.8]
params = {'h':50., 'src_type': 'gauss', 
          'gdX': gdX, 'gdY': gdY, 'gdZ': gdZ,
          'xmin': x_lims[0], 'xmax': x_lims[1], 
          'ymin': y_lims[0], 'ymax': y_lims[1],
          'zmin': y_lims[0], 'zmax': y_lims[1],
          'n_src_init': 1728}
k, pre_cv, est_csd = do_kcsd(ele_pos.T, vals_pots, h=1., 
                             gdx=gdX, gdy= gdY, gdz=gdZ,
                             xmin=x_lims[0], xmax=x_lims[1], 
                             ymin=y_lims[0], ymax=y_lims[1],
                             zmin=z_lims[0], zmax=z_lims[1],
                             n_src_init=1728, src_type='gauss')

true_csd = csd_profile(k.estm_pos, seed=1)
vals_csd = np.load('/home/mkowalska/FEM/kESI/csd_6_higher.npy')
vals_csd = vals_csd.reshape(pre_cv.shape)
fig = make_plots('kCSD3D.png', k.estm_pos, vals_csd[:, :, :, 0], 
               ele_x, ele_y, ele_z, vals_pots,
               k, pre_cv, est_csd)
#plt.savefig('kCSD3D_5x5x5_source2.png', dpi=300)


#fig = make_plots('kCSD3D_vs_kESI.png', k.estm_pos, vals_csd, 
#               ele_x, ele_y, ele_z, vals_pots,
#               k, est_csd, est_csd)


#level = 1
#
#index = np.where((f>0.1) | (f<-0.1))
#fig = plt.figure()
#ax = fig.add_subplot(111, projection='3d')
#im = ax.scatter(x[index], y[index], z[index], c=f[index], cmap=cm.bwr_r)
#ax.scatter(ele_x, ele_y, ele_z, 'k')
##im = ax.scatter(x, y, z, c=f.flatten(), cmap=cm.bwr_r)
#im.set_clim(-1, 1)
#ax.set_xlim([0., 10.])
#ax.set_ylim([0., 10.])
#ax.set_zlim([0., 10.])
#ax.set_xlabel('X')
#ax.set_zlabel('Z')
#ax.set_ylabel('Y')
#plt.colorbar(im)
#plt.show()

##### inverse model #####
import collections
import logging
from scipy.special import lpmv, erf

BRAIN_R = 7.9
SCALP_R = 9.0
WHITE_R = 7.5
RAD_TOL = 0.01
NECK_ANGLE = -np.pi / 3
NECK_AT = BRAIN_R * np.sin(NECK_ANGLE)


#class CartesianBase(object):
#    def __init__(self, ROW):
#        self.init(ROW.X, ROW.Y, ROW.Z, ROW)
class CartesianBase(object):
    def __init__(self, X, Y, Z):
        self.init(X, Y, Z)


class GaussianSourceBase(object):
    def init(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
        self._sigma2 = 0.1
        self._a = (2 * np.pi * self._sigma2) ** -1.5
#        self._ROW = ROW

    def __getattr__(self, name):
        return getattr(self._ROW, name)


class GaussianSourceFEM(CartesianBase, GaussianSourceBase):
    _BRAIN_R = 7.9
    NECK_ANGLE = -np.pi / 3
    NECK_AT = _BRAIN_R * np.sin(NECK_ANGLE)

    def csd(self, X, Y, Z):
        DIST2 = (X*X + Y*Y + Z*Z)
        return np.where((DIST2 <= self._BRAIN_R ** 2) & (Y > self.NECK_AT),
                        self._a * np.exp(-0.5 * ((X - self.x) ** 2 + (Y - self.y) ** 2 + (Z - self.z) ** 2)/self._sigma2),
                        0)

    def potential(self, electrodes):
        return self._ROW.loc[electrodes]
    

class GaussianSourceKCSD3D(GaussianSourceBase):
    _dtype = np.sqrt(0.5).__class__
    _fraction_of_erf_to_x_limit_in_0 = _dtype(2 / np.sqrt(np.pi))
    _x = _dtype(1.)
    _half = _dtype(0.5)
    _last = 2.
    _err = 1.
    while _err < _last:
        _radius_of_erf_to_x_limit_applicability = _x
        _last = _err
        _x *= _half
        _err = np.abs(erf(_x) - _fraction_of_erf_to_x_limit_in_0)

    def init(self, x, y, z, ROW):
        super(GaussianSourceKCSD3D, self).init(x, y, z, ROW)
        self.conductivity = 1/300
        self._b = 0.25 / (np.pi * 1/300)
        self._c = np.sqrt(0.5) / ROW.SIGMA

    def csd(self, X, Y, Z):
        return self._a * np.exp(-0.5 * ((X - self.x) ** 2 + (Y - self.y) ** 2 + (Z - self.z) ** 2)/self._sigma2)

    def potential(self, electrodes):
        R = np.sqrt((electrodes.X - self.x) ** 2 + (electrodes.Y - self.y) ** 2 + (electrodes.Z - self.z) ** 2)
        Rc = R * self._c
        return self._b * np.where(Rc >= self._radius_of_erf_to_x_limit_applicability,
                                  erf(Rc) / R,
                                  self._c * self._fraction_of_erf_to_x_limit_in_0)


class ElectrodeAware(object):
    def __init__(self, ROW, ELECTRODES):
        super(ElectrodeAware, self).__init__(ROW)
        self._ELECTRODES = ELECTRODES

    def potential(self, electrodes):
        return super(ElectrodeAware, self).potential(self._ELECTRODES.loc[electrodes])


class CartesianGaussianSourceFEM(CartesianBase, GaussianSourceFEM):
    pass


class CartesianGaussianSourceKCSD3D(CartesianBase, GaussianSourceKCSD3D):
    pass


class ElectrodeAwareCartesianGaussianSourceKCSD3D(ElectrodeAware,
                                                  CartesianGaussianSourceKCSD3D):
    pass